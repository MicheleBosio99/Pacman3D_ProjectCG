vec3 calculateSunlight(vec3 normal, vec3 viewDir) {
    vec3 sunDir = normalize(ubo.lightDirection);
    float diff = max(dot(normal, sunDir), 0.0);
    vec3 diffuse = ubo.lightColor.rgb * diff;
    vec3 reflectDir = reflect(-sunDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = vec3(0.5) * spec; // Assuming some specular intensity
    return diffuse + specular;
}

void main() {
    vec3 normal = normalize(fragNormCoord);
    vec3 viewDir = normalize(-fragPos);
    vec3 sunlight = calculateSunlight(normal, viewDir);

    vec3 textureColor = texture(texSampler, fragTexCoord).rgb;
    vec3 ambient = 0.2 * textureColor;
    vec3 color = ambient + sunlight * textureColor;

    outColor = vec4(color, 1.0);
}



// vec3 BRDF(vec3 V, vec3 N, vec3 L, vec3 Md, vec3 Ms, float gamma) {
// 	vec3 Diffuse = Md * clamp(dot(N, L),0.0,1.0);
// 	vec3 Specular = Ms * vec3(pow(clamp(dot(N, normalize(V + L)),0.0,1.0), gamma));
	
// 	return (Diffuse + Specular);
// }


// void main() {
//     vec3 Norm = normalize(fragNormCoord);
// 	vec3 EyeDir = normalize(ubo.viewerPos - fragPos);
// 	vec3 Albedo = texture(texSampler, fragTexCoord).rgb;
// 	float pex = 200.0f;
// 	float metallic = 1.0f;
// 	vec3 L = ubo.lightDirection;
// 	vec3 lightColor = ubo.lightColor.rgb * 0.8f;

// 	vec3 DiffSpec = BRDF(EyeDir, Norm, L, Albedo, vec3(metallic), pex);

// 	// A special type of non-uniform ambient color, invented for this course
// 	const vec3 cxp = vec3(1.0,0.5,0.5) * 0.15;
// 	const vec3 cxn = vec3(0.9,0.6,0.4) * 0.15;
// 	const vec3 cyp = vec3(0.3,1.0,1.0) * 0.15;
// 	const vec3 cyn = vec3(0.5,0.5,0.5) * 0.15;
// 	const vec3 czp = vec3(0.8,0.2,0.4) * 0.15;
// 	const vec3 czn = vec3(0.3,0.6,0.7) * 0.15;
	
// 	vec3 Ambient =((Norm.x > 0 ? cxp : cxn) * (Norm.x * Norm.x) +
// 				   (Norm.y > 0 ? cyp : cyn) * (Norm.y * Norm.y) +
// 				   (Norm.z > 0 ? czp : czn) * (Norm.z * Norm.z)) * Albedo;
	
// 	outColor = vec4(DiffSpec * lightColor.rgb + Ambient, 1.0f);
// }
